<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebTransport Control Panel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #fafafa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f5f5f5;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --text-tertiary: #999999;
            --border-light: #e5e5e5;
            --border-medium: #d0d0d0;
            --accent-success: #22c55e;
            --accent-warning: #f59e0b;
            --accent-error: #ef4444;
            --accent-info: #3b82f6;
            --shadow-light: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-medium: 0 4px 12px rgba(0, 0, 0, 0.05);
            --radius-small: 4px;
            --radius-medium: 8px;
            --radius-large: 12px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            font-size: 14px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
            min-height: 100vh;
        }

        .header {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-large);
            padding: 32px;
            margin-bottom: 24px;
            box-shadow: var(--shadow-light);
        }

        .header h1 {
            font-size: 28px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            letter-spacing: -0.025em;
        }

        .header .subtitle {
            color: var(--text-secondary);
            font-weight: 400;
        }

        .layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
        }

        .sidebar {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-large);
            padding: 24px;
            height: fit-content;
            box-shadow: var(--shadow-light);
            position: sticky;
            top: 24px;
        }

        .sidebar-section {
            margin-bottom: 32px;
        }

        .sidebar-section:last-child {
            margin-bottom: 0;
        }

        .sidebar-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .connection-status {
            padding: 12px 16px;
            text-align: center;
            font-weight: 500;
            font-size: 13px;
            border-radius: var(--radius-medium);
            margin-bottom: 24px;
            border: 1px solid;
            transition: all 0.2s ease;
        }

        .status-disconnected {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-color: var(--border-medium);
        }

        .status-connecting {
            background: #fef3c7;
            color: #92400e;
            border-color: #fcd34d;
        }

        .status-connected {
            background: #dcfce7;
            color: #166534;
            border-color: #86efac;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-small);
            background: var(--bg-secondary);
            font-family: inherit;
            font-size: 13px;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--text-primary);
            box-shadow: 0 0 0 2px rgba(26, 26, 26, 0.1);
        }

        .form-input::placeholder {
            color: var(--text-tertiary);
        }

        .form-hint {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-top: 4px;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 16px;
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-small);
            background: var(--bg-secondary);
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-primary);
        }

        .btn:hover:not(:disabled) {
            background: var(--bg-tertiary);
            border-color: var(--text-primary);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--text-primary);
            color: var(--bg-secondary);
            border-color: var(--text-primary);
        }

        .btn-primary:hover:not(:disabled) {
            background: #333333;
            border-color: #333333;
        }

        .btn-danger {
            background: var(--accent-error);
            color: white;
            border-color: var(--accent-error);
        }

        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
            border-color: #dc2626;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-card {
            background: var(--bg-tertiary);
            border-radius: var(--radius-medium);
            padding: 16px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .main-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-large);
            padding: 32px;
            box-shadow: var(--shadow-light);
        }

        .section {
            margin-bottom: 48px;
            padding-bottom: 32px;
            border-bottom: 1px solid var(--border-light);
        }

        .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .section-header {
            display: flex;
            align-items: center;
            margin-bottom: 24px;
        }

        .section-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: var(--text-primary);
            color: var(--bg-secondary);
            border-radius: 50%;
            font-size: 12px;
            font-weight: 600;
            margin-right: 16px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: -0.025em;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 24px;
            align-items: center;
        }

        .controls .form-input,
        .controls .form-select {
            min-width: 160px;
            padding: 8px 12px;
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-small);
            background: var(--bg-secondary);
            font-family: inherit;
            font-size: 13px;
            color: var(--text-primary);
        }

        .log-panel {
            border: 1px solid var(--border-light);
            border-radius: var(--radius-medium);
            background: var(--bg-tertiary);
            height: 280px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 12px;
        }

        .log-entry {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: var(--text-tertiary);
            font-weight: 500;
            min-width: 80px;
            flex-shrink: 0;
        }

        .log-content {
            flex: 1;
            word-break: break-word;
        }

        .log-send { color: var(--accent-info); }
        .log-receive { color: var(--accent-success); }
        .log-error { color: var(--accent-error); }
        .log-info { color: var(--text-primary); }

        .stream-list {
            border: 1px solid var(--border-light);
            border-radius: var(--radius-medium);
            margin-top: 20px;
            overflow: hidden;
        }

        .stream-item {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stream-item:last-child {
            border-bottom: none;
        }

        .stream-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stream-id {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 13px;
        }

        .stream-meta {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .stream-actions {
            display: flex;
            gap: 8px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .metric-card {
            background: var(--bg-tertiary);
            border-radius: var(--radius-medium);
            padding: 20px;
            text-align: center;
        }

        .metric-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .metric-unit {
            font-size: 13px;
            color: var(--text-secondary);
            margin-left: 2px;
        }

        .advanced-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-top: 24px;
        }

        .control-group {
            background: var(--bg-tertiary);
            border-radius: var(--radius-medium);
            padding: 20px;
        }

        .control-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .checkbox-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--text-primary);
        }

        .checkbox-item label {
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
        }

        .empty-state {
            text-align: center;
            padding: 32px 20px;
            color: var(--text-tertiary);
            font-style: italic;
            font-size: 13px;
        }

        /* Scrollbar styling */
        .log-panel::-webkit-scrollbar {
            width: 4px;
        }

        .log-panel::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .log-panel::-webkit-scrollbar-thumb {
            background: var(--border-medium);
            border-radius: 2px;
        }

        .log-panel::-webkit-scrollbar-thumb:hover {
            background: var(--text-tertiary);
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .layout {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .sidebar {
                position: static;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }
            
            .header {
                padding: 24px;
            }
            
            .main-content {
                padding: 24px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .advanced-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>WebTransport Control Panel</h1>
            <div class="subtitle">Modern protocol testing & validation suite</div>
        </div>

        <div class="layout">
            <div class="sidebar">
                <div class="sidebar-section">
                    <div class="sidebar-title">Connection</div>
                    <div class="connection-status status-disconnected" id="connectionStatus">
                        Disconnected
                    </div>
                    <div class="form-group">
                        <label class="form-label">Server URL</label>
                        <input type="text" class="form-input" id="serverUrl" value="https://localhost:4433/" placeholder="Enter server URL">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Certificate Hash (SHA-256)</label>
                        <input type="text" class="form-input" id="certHash" placeholder="Enter certificate hash">
                        <div class="form-hint">Automatically saved to browser storage</div>
                    </div>
                    <div class="button-group">
                        <button id="connectBtn" class="btn btn-primary" onclick="connect()">Connect</button>
                        <button id="disconnectBtn" class="btn btn-danger" onclick="disconnect()" disabled>Disconnect</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-title">Statistics</div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">BiDir Streams</div>
                            <div class="stat-value" id="bidirCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">UniDir Streams</div>
                            <div class="stat-value" id="unidirCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Active Streams</div>
                            <div class="stat-value" id="activeStreams">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Datagrams</div>
                            <div class="stat-value" id="datagramCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Bytes Sent</div>
                            <div class="stat-value" id="bytesSent">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Bytes Received</div>
                            <div class="stat-value" id="bytesReceived">0</div>
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-title">Session</div>
                    <div class="button-group">
                        <button class="btn" onclick="clearAllLogs()">Clear Logs</button>
                        <button class="btn" onclick="exportLogs()">Export Data</button>
                    </div>
                </div>
            </div>

            <div class="main-content">
                <div class="section">
                    <div class="section-header">
                        <div class="section-number">1</div>
                        <h2 class="section-title">Bidirectional Streams</h2>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="createBidirStream()">Create Stream</button>
                        <input type="text" class="form-input" id="bidirMessage" placeholder="Enter message content" value="Hello BiDir Stream!">
                        <button class="btn" onclick="sendBidirMessage()">Send Message</button>
                        <button class="btn btn-danger" onclick="closeBidirStream()">Close Stream</button>
                    </div>
                    <div class="log-panel" id="bidirLog"></div>
                    <div class="stream-list" id="bidirStreams">
                        <div class="empty-state">No active bidirectional streams</div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-header">
                        <div class="section-number">2</div>
                        <h2 class="section-title">Unidirectional Streams</h2>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="createUnidirStream()">Create Stream</button>
                        <input type="text" class="form-input" id="unidirMessage" placeholder="Enter message content" value="Hello UniDir Stream!">
                        <button class="btn" onclick="sendUnidirMessage()">Send Message</button>
                        <select class="form-select" id="dataSize">
                            <option value="1024">1 KB</option>
                            <option value="10240">10 KB</option>
                            <option value="102400">100 KB</option>
                            <option value="1048576">1 MB</option>
                        </select>
                        <button class="btn" onclick="sendLargeData()">Send Bulk Data</button>
                    </div>
                    <div class="log-panel" id="unidirLog"></div>
                    <div class="stream-list" id="unidirStreams">
                        <div class="empty-state">No active unidirectional streams</div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-header">
                        <div class="section-number">3</div>
                        <h2 class="section-title">Datagram Transport</h2>
                    </div>
                    <div class="controls">
                        <input type="text" class="form-input" id="datagramMessage" placeholder="Enter datagram content" value="Hello Datagram!">
                        <button class="btn" onclick="sendDatagram()">Send Single</button>
                        <select class="form-select" id="burstCount">
                            <option value="10">10 messages</option>
                            <option value="50">50 messages</option>
                            <option value="100">100 messages</option>
                            <option value="500">500 messages</option>
                        </select>
                        <button class="btn" onclick="sendDatagramBurst()">Send Burst</button>
                    </div>
                    <div class="log-panel" id="datagramLog"></div>
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-label">Send Rate</div>
                            <div class="metric-value" id="sendRate">0<span class="metric-unit">msg/s</span></div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Receive Rate</div>
                            <div class="metric-value" id="receiveRate">0<span class="metric-unit">msg/s</span></div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Round Trip</div>
                            <div class="metric-value" id="roundTrip">0<span class="metric-unit">ms</span></div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-header">
                        <div class="section-number">4</div>
                        <h2 class="section-title">Server-Initiated Streams</h2>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="requestServerStream()">Request Server Stream</button>
                        <select class="form-select" id="serverStreamType">
                            <option value="bidirectional">Bidirectional</option>
                            <option value="unidirectional">Unidirectional</option>
                        </select>
                        <input type="text" class="form-input" id="serverStreamMessage" placeholder="Message for server stream" value="Hello from client!">
                        <button class="btn" onclick="sendServerStreamMessage()">Send to Server Stream</button>
                    </div>
                    <div class="log-panel" id="serverStreamLog"></div>
                    <div class="stream-list" id="serverStreams">
                        <div class="empty-state">No server-initiated streams</div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-header">
                        <div class="section-number">5</div>
                        <h2 class="section-title">Advanced Testing</h2>
                    </div>
                    <div class="advanced-panel">
                        <div class="control-group">
                            <div class="control-title">Stream Options</div>
                            <div class="checkbox-list">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="autoReconnect">
                                    <label for="autoReconnect">Auto-reconnect streams</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="logBinary">
                                    <label for="logBinary">Log binary data</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="measureLatency" checked>
                                    <label for="measureLatency">Measure latency</label>
                                </div>
                            </div>
                        </div>
                        <div class="control-group">
                            <div class="control-title">Performance</div>
                            <div class="checkbox-list">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="highFrequency">
                                    <label for="highFrequency">High frequency mode</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="batchMessages">
                                    <label for="batchMessages">Batch messages</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="compressionTest">
                                    <label for="compressionTest">Test compression</label>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="controls">
                        <button class="btn" onclick="runStressTest()">Run Stress Test</button>
                        <button class="btn" onclick="runLatencyTest()">Latency Test</button>
                        <button class="btn" onclick="runThroughputTest()">Throughput Test</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-header">
                        <div class="section-number">6</div>
                        <h2 class="section-title">System Log</h2>
                    </div>
                    <div class="log-panel" id="systemLog"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Polyfill for Uint8Array.fromHex
        if (!Uint8Array.fromHex) {
            Uint8Array.fromHex = function (hexString) {
                const cleanHex = hexString.replace(/\s/g, '');
                if (cleanHex.length % 2 !== 0) {
                    throw new Error('Invalid hex string: odd number of characters');
                }
                if (!/^[0-9a-fA-F]*$/.test(cleanHex)) {
                    throw new Error('Invalid hex string: contains non-hex characters');
                }
                const bytes = new Uint8Array(cleanHex.length / 2);
                for (let i = 0; i < cleanHex.length; i += 2) {
                    bytes[i / 2] = parseInt(cleanHex.substr(i, 2), 16);
                }
                return bytes;
            };
        }

        // Global state
        let webTransport = null;
        let isConnected = false;
        let bidirStreams = new Map();
        let unidirStreams = new Map();
        let serverStreams = new Map();
        let nextStreamId = 1;

        let stats = {
            bidirCount: 0,
            unidirCount: 0,
            activeStreams: 0,
            datagramCount: 0,
            bytesSent: 0,
            bytesReceived: 0
        };

        let performanceMetrics = {
            sendRate: 0,
            receiveRate: 0,
            roundTrip: 0,
            lastSendTime: 0,
            lastReceiveTime: 0
        };

        // Initialize localStorage integration
        function loadStoredSettings() {
            const storedHash = localStorage.getItem('webtransport-cert-hash');
            const storedUrl = localStorage.getItem('webtransport-server-url');
            
            if (storedHash) {
                document.getElementById('certHash').value = storedHash;
            }
            if (storedUrl) {
                document.getElementById('serverUrl').value = storedUrl;
            }
        }

        function saveSettings() {
            const certHash = document.getElementById('certHash').value.trim();
            const serverUrl = document.getElementById('serverUrl').value.trim();
            
            if (certHash) {
                localStorage.setItem('webtransport-cert-hash', certHash);
            }
            if (serverUrl) {
                localStorage.setItem('webtransport-server-url', serverUrl);
            }
        }

        // Logging functions
        function addLog(logId, message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById(logId);
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `
                <div class="log-time">${timestamp}</div>
                <div class="log-content log-${type}">${message}</div>
            `;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
            
            // Also log to system log if not already system log
            if (logId !== 'systemLog') {
                const sectionName = logId.replace('Log', '').replace(/([A-Z])/g, ' $1').trim();
                addLog('systemLog', `${sectionName}: ${message}`, type);
            }
        }

        function updateStats() {
            document.getElementById('bidirCount').textContent = stats.bidirCount;
            document.getElementById('unidirCount').textContent = stats.unidirCount;
            document.getElementById('activeStreams').textContent = stats.activeStreams;
            document.getElementById('datagramCount').textContent = stats.datagramCount;
            document.getElementById('bytesSent').textContent = formatBytes(stats.bytesSent);
            document.getElementById('bytesReceived').textContent = formatBytes(stats.bytesReceived);
        }

        function updatePerformanceMetrics() {
            document.getElementById('sendRate').innerHTML = `${performanceMetrics.sendRate}<span class="metric-unit">msg/s</span>`;
            document.getElementById('receiveRate').innerHTML = `${performanceMetrics.receiveRate}<span class="metric-unit">msg/s</span>`;
            document.getElementById('roundTrip').innerHTML = `${performanceMetrics.roundTrip}<span class="metric-unit">ms</span>`;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            statusElement.className = `connection-status status-${status}`;
            
            switch (status) {
                case 'disconnected':
                    statusElement.textContent = 'Disconnected';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    isConnected = false;
                    break;
                case 'connecting':
                    statusElement.textContent = 'Connecting...';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = true;
                    break;
                case 'connected':
                    statusElement.textContent = 'Connected';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    isConnected = true;
                    break;
            }
        }

        // Connection functions
        async function connect() {
            try {
                updateConnectionStatus('connecting');
                addLog('systemLog', 'Initiating WebTransport connection...', 'info');
                
                const url = document.getElementById('serverUrl').value.trim();
                const hashHex = document.getElementById('certHash').value.trim();
                
                if (!url) {
                    throw new Error('Server URL is required');
                }
                
                if (!hashHex) {
                    throw new Error('Certificate hash is required');
                }
                
                const hashBytes = Uint8Array.fromHex(hashHex);
                
                webTransport = new WebTransport(url, {
                    allowPooling: false,
                    serverCertificateHashes: [{
                        algorithm: "sha-256",
                        value: hashBytes.buffer,
                    }],
                });

                await webTransport.ready;
                updateConnectionStatus('connected');
                addLog('systemLog', 'WebTransport connection established successfully', 'info');
                
                saveSettings();
                setupDatagramReader();
                setupIncomingStreamReader();
                
            } catch (error) {
                updateConnectionStatus('disconnected');
                addLog('systemLog', `Connection failed: ${error.message}`, 'error');
            }
        }

        async function disconnect() {
            if (webTransport) {
                try {
                    bidirStreams.clear();
                    unidirStreams.clear();
                    serverStreams.clear();
                    updateStreamLists();
                    
                    await webTransport.close();
                } catch (error) {
                    addLog('systemLog', `Disconnect error: ${error.message}`, 'error');
                }
                webTransport = null;
            }
            updateConnectionStatus('disconnected');
            addLog('systemLog', 'WebTransport disconnected', 'info');
            
            stats.activeStreams = 0;
            updateStats();
        }

        // Bidirectional stream functions
        async function createBidirStream() {
            if (!isConnected) {
                addLog('bidirLog', 'Not connected to server', 'error');
                return;
            }

            try {
                const stream = await webTransport.createBidirectionalStream();
                const streamId = `bidir-${nextStreamId++}`;
                
                bidirStreams.set(streamId, {
                    stream: stream,
                    created: Date.now()
                });
                
                stats.bidirCount++;
                stats.activeStreams++;
                updateStats();
                updateStreamLists();
                
                addLog('bidirLog', `Created bidirectional stream: ${streamId}`, 'info');
                setupStreamReader(streamId, stream, 'bidirLog');
                
            } catch (error) {
                addLog('bidirLog', `Failed to create stream: ${error.message}`, 'error');
            }
        }

        async function sendBidirMessage() {
            if (bidirStreams.size === 0) {
                addLog('bidirLog', 'No active bidirectional streams', 'error');
                return;
            }

            const message = document.getElementById('bidirMessage').value.trim();
            if (!message) {
                addLog('bidirLog', 'Message content is empty', 'error');
                return;
            }

            const streamEntry = Array.from(bidirStreams.values()).pop();
            try {
                const data = new TextEncoder().encode(message);
                const writer = streamEntry.stream.writable.getWriter();
                
                await writer.write(data);
                writer.releaseLock();
                
                stats.bytesSent += data.length;
                updateStats();
                addLog('bidirLog', `Sent: ${message} (${data.length} bytes)`, 'send');
                
            } catch (error) {
                addLog('bidirLog', `Send failed: ${error.message}`, 'error');
            }
        }

        async function closeBidirStream() {
            if (bidirStreams.size === 0) {
                addLog('bidirLog', 'No active bidirectional streams to close', 'error');
                return;
            }

            const streamId = Array.from(bidirStreams.keys()).pop();
            const streamEntry = bidirStreams.get(streamId);
            
            try {
                await streamEntry.stream.writable.close();
                bidirStreams.delete(streamId);
                stats.activeStreams--;
                updateStats();
                updateStreamLists();
                addLog('bidirLog', `Closed stream: ${streamId}`, 'info');
                
            } catch (error) {
                addLog('bidirLog', `Failed to close stream: ${error.message}`, 'error');
            }
        }

        // Unidirectional stream functions
        async function createUnidirStream() {
            if (!isConnected) {
                addLog('unidirLog', 'Not connected to server', 'error');
                return;
            }

            try {
                const stream = await webTransport.createUnidirectionalStream();
                const streamId = `unidir-${nextStreamId++}`;
                
                unidirStreams.set(streamId, {
                    stream: stream,
                    created: Date.now()
                });
                
                stats.unidirCount++;
                stats.activeStreams++;
                updateStats();
                updateStreamLists();
                
                addLog('unidirLog', `Created unidirectional stream: ${streamId}`, 'info');
                
            } catch (error) {
                addLog('unidirLog', `Failed to create stream: ${error.message}`, 'error');
            }
        }

        async function sendUnidirMessage() {
            if (unidirStreams.size === 0) {
                addLog('unidirLog', 'No active unidirectional streams', 'error');
                return;
            }

            const message = document.getElementById('unidirMessage').value.trim();
            if (!message) {
                addLog('unidirLog', 'Message content is empty', 'error');
                return;
            }

            const streamEntry = Array.from(unidirStreams.values()).pop();
            try {
                const data = new TextEncoder().encode(message);
                const writer = streamEntry.stream.getWriter();
                
                await writer.write(data);
                writer.releaseLock();
                
                stats.bytesSent += data.length;
                updateStats();
                addLog('unidirLog', `Sent: ${message} (${data.length} bytes)`, 'send');
                
            } catch (error) {
                addLog('unidirLog', `Send failed: ${error.message}`, 'error');
            }
        }

        async function sendLargeData() {
            if (unidirStreams.size === 0) {
                await createUnidirStream();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const size = parseInt(document.getElementById('dataSize').value);
            const streamEntry = Array.from(unidirStreams.values()).pop();
            
            if (!streamEntry) {
                addLog('unidirLog', 'Failed to create stream for bulk data', 'error');
                return;
            }
            
            try {
                const data = new Uint8Array(size);
                crypto.getRandomValues(data);
                
                const writer = streamEntry.stream.getWriter();
                await writer.write(data);
                writer.releaseLock();
                
                stats.bytesSent += data.length;
                updateStats();
                addLog('unidirLog', `Sent bulk data: ${formatBytes(size)}`, 'send');
                
            } catch (error) {
                addLog('unidirLog', `Bulk send failed: ${error.message}`, 'error');
            }
        }

        // Datagram functions
        async function setupDatagramReader() {
            if (!webTransport || !webTransport.datagrams) return;
            
            const reader = webTransport.datagrams.readable.getReader();
            
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        addLog('datagramLog', 'Datagram reader closed', 'info');
                        break;
                    }
                    
                    const message = new TextDecoder().decode(value);
                    stats.bytesReceived += value.length;
                    stats.datagramCount++;
                    
                    const now = Date.now();
                    if (performanceMetrics.lastReceiveTime > 0) {
                        const timeDiff = now - performanceMetrics.lastReceiveTime;
                        if (timeDiff > 0) {
                            performanceMetrics.receiveRate = Math.round(1000 / timeDiff);
                        }
                    }
                    performanceMetrics.lastReceiveTime = now;
                    
                    // Handle PONG responses for latency measurement
                    if (message.startsWith('PONG_') && document.getElementById('measureLatency').checked) {
                        const parts = message.split('_');
                        if (parts.length >= 2) {
                            const originalTimestamp = parseInt(parts[1]);
                            if (!isNaN(originalTimestamp)) {
                                const latency = now - originalTimestamp;
                                performanceMetrics.roundTrip = Math.round(latency);
                            }
                        }
                    }
                    
                    updateStats();
                    updatePerformanceMetrics();
                    addLog('datagramLog', `Received: ${message}`, 'receive');
                }
            } catch (error) {
                addLog('datagramLog', `Datagram read error: ${error.message}`, 'error');
            } finally {
                reader.releaseLock();
            }
        }

        async function sendDatagram() {
            if (!isConnected || !webTransport.datagrams) {
                addLog('datagramLog', 'Not connected or datagrams not supported', 'error');
                return;
            }

            const message = document.getElementById('datagramMessage').value.trim();
            if (!message) {
                addLog('datagramLog', 'Message content is empty', 'error');
                return;
            }

            try {
                let finalMessage = message;
                if (document.getElementById('measureLatency').checked && message.startsWith('PING')) {
                    finalMessage = `PING_${Date.now()}`;
                }
                
                const data = new TextEncoder().encode(finalMessage);
                const writer = webTransport.datagrams.writable.getWriter();
                
                const sendTime = Date.now();
                await writer.write(data);
                writer.releaseLock();
                
                if (performanceMetrics.lastSendTime > 0) {
                    const timeDiff = sendTime - performanceMetrics.lastSendTime;
                    if (timeDiff > 0) {
                        performanceMetrics.sendRate = Math.round(1000 / timeDiff);
                    }
                }
                performanceMetrics.lastSendTime = sendTime;
                
                stats.bytesSent += data.length;
                updateStats();
                updatePerformanceMetrics();
                addLog('datagramLog', `Sent: ${finalMessage}`, 'send');
                
            } catch (error) {
                addLog('datagramLog', `Send failed: ${error.message}`, 'error');
            }
        }

        async function sendDatagramBurst() {
            if (!isConnected || !webTransport.datagrams) {
                addLog('datagramLog', 'Not connected or datagrams not supported', 'error');
                return;
            }

            const count = parseInt(document.getElementById('burstCount').value);
            const baseMessage = document.getElementById('datagramMessage').value.trim();
            
            if (!baseMessage) {
                addLog('datagramLog', 'Message content is empty', 'error');
                return;
            }
            
            addLog('datagramLog', `Starting burst test: ${count} messages`, 'info');
            
            try {
                const writer = webTransport.datagrams.writable.getWriter();
                const startTime = Date.now();
                
                for (let i = 0; i < count; i++) {
                    const message = `${baseMessage} #${i + 1}`;
                    const data = new TextEncoder().encode(message);
                    
                    await writer.write(data);
                    stats.bytesSent += data.length;
                    
                    if ((i + 1) % 50 === 0) {
                        updateStats();
                        addLog('datagramLog', `Progress: ${i + 1}/${count} messages sent`, 'info');
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                writer.releaseLock();
                const duration = Date.now() - startTime;
                const rate = Math.round((count * 1000) / duration);
                
                updateStats();
                addLog('datagramLog', `Burst completed: ${count} messages in ${duration}ms (${rate} msg/s)`, 'info');
                
            } catch (error) {
                addLog('datagramLog', `Burst test failed: ${error.message}`, 'error');
            }
        }

        // Server-initiated streams
        async function setupIncomingStreamReader() {
            if (!webTransport) return;
            
            // Handle incoming bidirectional streams
            const bidirReader = webTransport.incomingBidirectionalStreams.getReader();
            
            (async () => {
                try {
                    while (true) {
                        const { value, done } = await bidirReader.read();
                        if (done) {
                            addLog('serverStreamLog', 'Incoming bidirectional stream reader closed', 'info');
                            break;
                        }
                        
                        const streamId = `server-bidir-${nextStreamId++}`;
                        serverStreams.set(streamId, {
                            stream: value,
                            type: 'bidirectional',
                            created: Date.now()
                        });
                        
                        stats.activeStreams++;
                        updateStats();
                        updateStreamLists();
                        
                        addLog('serverStreamLog', `Server opened bidirectional stream: ${streamId}`, 'info');
                        setupStreamReader(streamId, value, 'serverStreamLog');
                    }
                } catch (error) {
                    addLog('serverStreamLog', `Incoming bidirectional stream error: ${error.message}`, 'error');
                } finally {
                    bidirReader.releaseLock();
                }
            })();

            // Handle incoming unidirectional streams
            const unidirReader = webTransport.incomingUnidirectionalStreams.getReader();
            
            (async () => {
                try {
                    while (true) {
                        const { value, done } = await unidirReader.read();
                        if (done) {
                            addLog('serverStreamLog', 'Incoming unidirectional stream reader closed', 'info');
                            break;
                        }
                        
                        const streamId = `server-unidir-${nextStreamId++}`;
                        serverStreams.set(streamId, {
                            stream: value,
                            type: 'unidirectional',
                            created: Date.now()
                        });
                        
                        stats.activeStreams++;
                        updateStats();
                        updateStreamLists();
                        
                        addLog('serverStreamLog', `Server opened unidirectional stream: ${streamId}`, 'info');
                        setupStreamReader(streamId, value, 'serverStreamLog');
                    }
                } catch (error) {
                    addLog('serverStreamLog', `Incoming unidirectional stream error: ${error.message}`, 'error');
                } finally {
                    unidirReader.releaseLock();
                }
            })();
        }

        async function requestServerStream() {
            const streamType = document.getElementById('serverStreamType').value;
            const requestMessage = `REQUEST_STREAM:${streamType}`;
            
            if (!isConnected || !webTransport.datagrams) {
                addLog('serverStreamLog', 'Not connected or datagrams not supported', 'error');
                return;
            }

            try {
                const data = new TextEncoder().encode(requestMessage);
                const writer = webTransport.datagrams.writable.getWriter();
                
                await writer.write(data);
                writer.releaseLock();
                
                stats.bytesSent += data.length;
                updateStats();
                addLog('serverStreamLog', `Requested server stream: ${streamType}`, 'send');
                
            } catch (error) {
                addLog('serverStreamLog', `Stream request failed: ${error.message}`, 'error');
            }
        }

        async function sendServerStreamMessage() {
            if (serverStreams.size === 0) {
                addLog('serverStreamLog', 'No active server streams', 'error');
                return;
            }

            const message = document.getElementById('serverStreamMessage').value.trim();
            if (!message) {
                addLog('serverStreamLog', 'Message content is empty', 'error');
                return;
            }

            const serverStreamEntries = Array.from(serverStreams.entries());
            let targetStream = null;

            for (let i = serverStreamEntries.length - 1; i >= 0; i--) {
                const [streamId, streamData] = serverStreamEntries[i];
                if (streamData.type === 'bidirectional' && streamData.stream.writable) {
                    targetStream = { id: streamId, data: streamData };
                    break;
                }
            }

            if (!targetStream) {
                addLog('serverStreamLog', 'No writable server streams available (need bidirectional)', 'error');
                return;
            }

            try {
                const data = new TextEncoder().encode(message);
                const writer = targetStream.data.stream.writable.getWriter();
                
                await writer.write(data);
                writer.releaseLock();
                
                stats.bytesSent += data.length;
                updateStats();
                addLog('serverStreamLog', `Sent to ${targetStream.id}: ${message} (${data.length} bytes)`, 'send');
                
            } catch (error) {
                addLog('serverStreamLog', `Send to server stream failed: ${error.message}`, 'error');
            }
        }

        // Stream reader setup
        async function setupStreamReader(streamId, stream, logId) {
            if (!stream.readable) return;
            
            const reader = stream.readable.getReader();
            
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        addLog(logId, `Stream ${streamId} closed by peer`, 'info');
                        break;
                    }
                    
                    const message = new TextDecoder().decode(value);
                    stats.bytesReceived += value.length;
                    updateStats();
                    addLog(logId, `Received on ${streamId}: ${message}`, 'receive');
                }
            } catch (error) {
                addLog(logId, `Stream ${streamId} read error: ${error.message}`, 'error');
            } finally {
                reader.releaseLock();
            }
        }

        // Stream list management
        function updateStreamLists() {
            updateStreamList('bidirStreams', bidirStreams, 'bidirectional');
            updateStreamList('unidirStreams', unidirStreams, 'unidirectional');
            updateStreamList('serverStreams', serverStreams, 'server');
        }

        function updateStreamList(containerId, streams, type) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (streams.size === 0) {
                const emptyText = type === 'server' ? 'No server-initiated streams' : 
                                 type === 'bidirectional' ? 'No active bidirectional streams' :
                                 'No active unidirectional streams';
                container.innerHTML = `<div class="empty-state">${emptyText}</div>`;
                return;
            }
            
            streams.forEach((streamData, streamId) => {
                const streamItem = document.createElement('div');
                streamItem.className = 'stream-item';
                
                const age = Math.round((Date.now() - streamData.created) / 1000);
                let streamTypeLabel = type;
                
                if (type === 'server') {
                    streamTypeLabel = `server-${streamData.type}`;
                }
                
                streamItem.innerHTML = `
                    <div class="stream-info">
                        <div class="stream-id">${streamId}</div>
                        <div class="stream-meta">${streamTypeLabel}  ${age}s old</div>
                    </div>
                    <div class="stream-actions">
                        <button class="btn btn-danger" onclick="closeStream('${streamId}', '${containerId}')">Close</button>
                    </div>
                `;
                
                container.appendChild(streamItem);
            });
        }

        async function closeStream(streamId, containerId) {
            let streamMap;
            let logId;
            
            switch (containerId) {
                case 'bidirStreams':
                    streamMap = bidirStreams;
                    logId = 'bidirLog';
                    break;
                case 'unidirStreams':
                    streamMap = unidirStreams;
                    logId = 'unidirLog';
                    break;
                case 'serverStreams':
                    streamMap = serverStreams;
                    logId = 'serverStreamLog';
                    break;
                default:
                    return;
            }
            
            const streamData = streamMap.get(streamId);
            if (!streamData) return;
            
            try {
                if (streamData.stream.writable) {
                    await streamData.stream.writable.close();
                }
                streamMap.delete(streamId);
                stats.activeStreams--;
                updateStats();
                updateStreamLists();
                addLog(logId, `Closed stream: ${streamId}`, 'info');
                
            } catch (error) {
                addLog(logId, `Failed to close stream ${streamId}: ${error.message}`, 'error');
            }
        }

        // Advanced testing functions
        async function runStressTest() {
            addLog('systemLog', 'Starting stress test...', 'info');
            
            const promises = [];
            
            for (let i = 0; i < 3; i++) {
                promises.push(createBidirStream());
                promises.push(createUnidirStream());
            }
            
            await Promise.all(promises);
            await sendDatagramBurst();
            await requestServerStream();
            
            addLog('systemLog', 'Stress test completed', 'info');
        }

        async function runLatencyTest() {
            if (!isConnected) {
                addLog('systemLog', 'Not connected', 'error');
                return;
            }
            
            addLog('systemLog', 'Starting latency test...', 'info');
            
            const iterations = 10;
            const latencies = [];
            
            for (let i = 0; i < iterations; i++) {
                const startTime = performance.now();
                const message = `PING_${Date.now()}`;
                
                try {
                    const data = new TextEncoder().encode(message);
                    const writer = webTransport.datagrams.writable.getWriter();
                    await writer.write(data);
                    writer.releaseLock();
                    
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    const latency = performance.now() - startTime;
                    latencies.push(latency);
                    
                } catch (error) {
                    addLog('systemLog', `Latency test iteration ${i + 1} failed: ${error.message}`, 'error');
                }
            }
            
            if (latencies.length > 0) {
                const avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length;
                performanceMetrics.roundTrip = Math.round(avgLatency);
                updatePerformanceMetrics();
                addLog('systemLog', `Latency test completed: ${Math.round(avgLatency)}ms average`, 'info');
            }
        }

        async function runThroughputTest() {
            if (!isConnected) {
                addLog('systemLog', 'Not connected', 'error');
                return;
            }
            
            addLog('systemLog', 'Starting throughput test...', 'info');
            
            const testData = new Uint8Array(512 * 1024); // 512KB
            crypto.getRandomValues(testData);
            
            await createUnidirStream();
            const streamEntry = Array.from(unidirStreams.values()).pop();
            
            if (!streamEntry) {
                addLog('systemLog', 'Failed to create stream for throughput test', 'error');
                return;
            }
            
            const startTime = performance.now();
            
            try {
                const writer = streamEntry.stream.getWriter();
                
                const chunkSize = 32 * 1024; // 32KB chunks
                for (let offset = 0; offset < testData.length; offset += chunkSize) {
                    const end = Math.min(offset + chunkSize, testData.length);
                    const chunk = testData.slice(offset, end);
                    await writer.write(chunk);
                }
                
                writer.releaseLock();
                
                const duration = performance.now() - startTime;
                const throughput = (testData.length * 8) / (duration / 1000);
                const mbps = (throughput / (1024 * 1024)).toFixed(2);
                
                stats.bytesSent += testData.length;
                updateStats();
                
                addLog('systemLog', `Throughput test completed: ${mbps} Mbps`, 'info');
                
            } catch (error) {
                addLog('systemLog', `Throughput test failed: ${error.message}`, 'error');
            }
        }

        // Utility functions
        function clearAllLogs() {
            const logIds = ['bidirLog', 'unidirLog', 'datagramLog', 'serverStreamLog', 'systemLog'];
            logIds.forEach(id => {
                document.getElementById(id).innerHTML = '';
            });
            addLog('systemLog', 'All logs cleared', 'info');
        }

        function exportLogs() {
            const logs = {
                timestamp: new Date().toISOString(),
                connection: {
                    url: document.getElementById('serverUrl').value,
                    status: isConnected ? 'connected' : 'disconnected',
                    certHash: document.getElementById('certHash').value
                },
                statistics: stats,
                performance: performanceMetrics,
                streams: {
                    bidirectional: Array.from(bidirStreams.keys()),
                    unidirectional: Array.from(unidirStreams.keys()),
                    server: Array.from(serverStreams.keys())
                }
            };
            
            const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `webtransport-session-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            addLog('systemLog', 'Session data exported', 'info');
        }

        // Initialize application
        function init() {
            loadStoredSettings();
            updateConnectionStatus('disconnected');
            updateStats();
            updatePerformanceMetrics();
            updateStreamLists();
            addLog('systemLog', 'WebTransport Control Panel initialized', 'info');
            
            // Performance monitoring
            setInterval(() => {
                if (performanceMetrics.sendRate > 0) {
                    performanceMetrics.sendRate = Math.max(0, performanceMetrics.sendRate - 1);
                }
                if (performanceMetrics.receiveRate > 0) {
                    performanceMetrics.receiveRate = Math.max(0, performanceMetrics.receiveRate - 1);
                }
                updatePerformanceMetrics();
            }, 1000);
        }

        // Start the application
        init();
    </script>
</body>
</html>